// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `convert_bbox`, `image_to_tensor`, `non_max_suppression`, `process_output`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicImage>>
abstract class DynamicImage implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<YOLO>>
abstract class Yolo implements RustOpaqueInterface {
  /// Изменяет размер изображения с сохранением соотношения сторон и добавляет padding
  ///
  /// Возвращает обработанное изображение, отступы по X/Y и коэффициент масштабирования
  Future<(DynamicImage, (double, double), double)> letterbox({
    required DynamicImage image,
    required (int, int) targetSize,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Создаёт новый экземпляр YOLO-модели на основе ONNX-файла.
  ///
  /// # Аргументы
  ///
  /// * `model_path` — путь к ONNX-модели;
  /// * `class_labels` — вектор строк с метками классов;
  /// * `confidence_threshold` — минимальный порог уверенности для вывода детекций;
  /// * `nms_threshold` — порог для non-maximum suppression.
  ///
  /// # Возвращает
  ///
  /// `Result<YOLO>` — возвращает экземпляр YOLO при успешной инициализации, иначе ошибку.
  ///
  /// # Ошибки
  ///
  /// Возникает, если не удаётся загрузить ONNX-модель, или если модель не соответствует ожидаемому формату.
  ///
  /// # Пример
  /// ```rust
  /// let class_labels = vec![
  ///     "polyp".to_string(),
  ///     "other_class".to_string(),
  /// ];
  /// let yolo = YOLO::new("./best.onnx", class_labels, 0.25, 0.7)?;
  /// ```
  static Future<Yolo> newInstance({
    required String modelPath,
    required List<String> classLabels,
    required double confidenceThreshold,
    required double nmsThreshold,
  }) => RustLib.instance.api.crateApiYoloEndoYoloYoloNew(
    modelPath: modelPath,
    classLabels: classLabels,
    confidenceThreshold: confidenceThreshold,
    nmsThreshold: nmsThreshold,
  );

  /// Выполняет предсказание объектов на изображении.
  ///
  /// # Аргументы
  ///
  /// * `img` — изображение (`DynamicImage`), на котором будет выполнено предсказание.
  ///
  /// # Возвращает
  ///
  /// `Result<Vec<Detection>>` — список предсказанных объектов (`label`, `confidence`, `bbox`).
  ///
  /// # Ошибки
  ///
  /// Возвращает ошибку, если входное изображение не может быть преобразовано к формату,
  /// подходящему для модели, либо если инференс не удался.
  ///
  /// # Пример
  /// ```rust
  /// let img = image::open("example.jpg")?;
  /// let detections = yolo.predict(&img)?;
  /// for det in detections {
  ///     println!("{}: {:.2}, {:?}", det.label, det.confidence, det.bbox);
  /// }
  /// ```
  Future<List<DetectionResult>> predict({required DynamicImage image});
}

/// Прямоугольник, ограничивающий обнаруженный объект.
///
/// Хранит координаты двух углов: верхнего левого (`x1`, `y1`) и нижнего правого (`x2`, `y2`).
class BoundingBox {
  final double x1;
  final double y1;
  final double x2;
  final double y2;

  const BoundingBox({
    required this.x1,
    required this.y1,
    required this.x2,
    required this.y2,
  });

  Future<double> intersection({required BoundingBox other}) => RustLib
      .instance
      .api
      .crateApiYoloEndoYoloBoundingBoxIntersection(that: this, other: other);

  Future<double> iou({required BoundingBox other}) => RustLib.instance.api
      .crateApiYoloEndoYoloBoundingBoxIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<BoundingBox> newInstance({
    required double x1,
    required double y1,
    required double x2,
    required double y2,
  }) => RustLib.instance.api.crateApiYoloEndoYoloBoundingBoxNew(
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2,
  );

  Future<double> union({required BoundingBox other}) => RustLib.instance.api
      .crateApiYoloEndoYoloBoundingBoxUnion(that: this, other: other);

  @override
  int get hashCode => x1.hashCode ^ y1.hashCode ^ x2.hashCode ^ y2.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BoundingBox &&
          runtimeType == other.runtimeType &&
          x1 == other.x1 &&
          y1 == other.y1 &&
          x2 == other.x2 &&
          y2 == other.y2;
}

/// Представляет предсказание объекта.
///
/// # Поля
///
/// * `label` — строка с меткой класса (напр., `"polyp"`);
/// * `confidence` — уверенность модели (0.0 — 1.0);
/// * `bbox` — кортеж `(x_1, y_1, x_2, y_2)` в пикселях.
///
/// # Пример
/// ```rust
/// DetectionResult {
///     label: "polyp".to_string(),
///     confidence: 0.92,
///     bbox: (100, 50, 200, 150),
/// }
/// ```
class DetectionResult {
  final BoundingBox bbox;
  final String label;
  final double confidence;

  const DetectionResult({
    required this.bbox,
    required this.label,
    required this.confidence,
  });

  @override
  int get hashCode => bbox.hashCode ^ label.hashCode ^ confidence.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DetectionResult &&
          runtimeType == other.runtimeType &&
          bbox == other.bbox &&
          label == other.label &&
          confidence == other.confidence;
}
